# 5주차 발표: 다이나믹 프로그래밍

- 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용
- 특정한 알고리즘이 아닌 하나의 문제해결법 → 다양한 문제에서 활용가능!

## 1. 사용하는 이유??

- 재귀와 방식 유사
- 차이점은 재귀의 특징인 불필요한 반복호출을 DP의 저장기능으로 없엠 → 시간복잡도 대폭 줄일 수 있음
- 따라서 실질적으로 거의 사용되지 않는 재귀에 비해 DP는 많은 프로그래머가 사용한다.

![스크린샷 2023-02-03 오후 4.42.27.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%B5%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b8eb7c6f4afb46769b5f7364d28bfc9f/%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25B0%25EC%2583%25B7_2023-02-03_%25EC%2598%25A4%25ED%259B%2584_4.42.27.png)

## 2. DP 사용 조건

- 1. 동일한 부분 문제들이 반복하여 나타나는 경우
- 2. 부분 문제들의 답이 전체 문제의 답이 되는 경우

ex.) 피보나치 수열

- f(0)이라는 문제가 3번, f(1)은 5번, f(2)는 3번, f(3)은 2번 반복해서 나타남.
- 전체 문제 f(5)의 답은 f(4)라는 부분문제의 답과 f(3)이라는 부분문제의 답의 합이다.

→ 피보나치 수열은 DP 사용 가능!

## 3. DP 사용 방법

- 하나의 배열 만들기 → 정답으로 가는 흔적을 보여주는 배열
- Top-down(재귀함수), Bottom-up(DP)

ex.) 피보나치 수열

![스크린샷 2023-02-03 오후 5.39.47.png](5%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%87%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%82%E1%85%A1%E1%84%86%E1%85%B5%E1%86%A8%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20b8eb7c6f4afb46769b5f7364d28bfc9f/%25EC%258A%25A4%25ED%2581%25AC%25EB%25A6%25B0%25EC%2583%25B7_2023-02-03_%25EC%2598%25A4%25ED%259B%2584_5.39.47.png)

- Top-down

> fib(0) = 1, fib(1) = 1;
> 

> fib(4) = fib(3) + fib(2);
> 

> fib(3) = fib(2) + fib(1);
> 

> fib(2) = fib(1) + fib(0);
> 

- Bottom-up

> int sub[];
> 

> sub[0] = 1, sub[1] = 1;
> 

> sub[2] = sub[0] + sub[1];
> 

> sub[3] = sub[1] + sub[2];
> 

> sub[4] = sub[2] + sub[3]; == fib(4)
> 

**T-d는 직관적이지만 스택에 한계가 있으므로 B-u으로 코딩하는 연습 필요!**